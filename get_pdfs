#!/usr/bin/env python3
# /// script
# dependencies = [
#   "requests>=2.32.0",
# ]
# ///
"""
Download PDFs for references using the Unpaywall API.
Extracts DOIs from references.txt and downloads available PDFs.
"""
import argparse
import base64
import logging
import os
import re
import sys
from pathlib import Path

import requests

# Manifest status constants
STATUS_FOUND = 'Found'
STATUS_NOT_FOUND = 'Not found'

# Internal status constants (for logging/logic, but saved as 'Not found' in manifest)
STATUS_UNAVAILABLE = 'Unavailable'  # No open access available
STATUS_DOWNLOAD_FAILED = 'DownloadFailed'  # Download error
STATUS_NETWORK_ERROR = 'NetworkError'  # API/network error


def extract_dois(references_file):
    """Extract DOIs from the references file.

    Args:
        references_file: Path to file containing references

    Returns:
        List of DOIs extracted from the file

    Raises:
        FileNotFoundError: If references file doesn't exist
        IOError: If file cannot be read
    """
    dois = []

    try:
        with open(references_file, 'r') as f:
            content = f.read()
    except FileNotFoundError:
        raise FileNotFoundError(
            f'References file not found: {references_file}\n'
            f'Please create the file or specify a different path with --references'
        )
    except IOError as e:
        raise IOError(f'Cannot read references file {references_file}: {e}')

    # Pattern to match [DOI]:, [doi]:, DOI:, or doi: with optional whitespace
    # Followed by the DOI (format: 10.XXXX/...)
    pattern = r'(?:\[\s*[Dd][Oo][Ii]\s*\]|[Dd][Oo][Ii]):\s*(10\.\S+?)(?:\s|$)'

    matches = re.findall(pattern, content)

    for doi in matches:
        # Clean up any trailing punctuation
        doi = doi.rstrip('.,;')
        dois.append(doi)

    return dois


def get_pdf_url(doi, email):
    """
    Query Unpaywall API to get PDF URL for a DOI.

    Args:
        doi: The DOI to look up
        email: Email address for Unpaywall API (required)

    Returns:
        Tuple of (pdf_url, error_type) where:
        - pdf_url is the URL if available, None otherwise
        - error_type is STATUS_NETWORK_ERROR if network/API failed, None otherwise
    """
    api_url = f'https://api.unpaywall.org/v2/{doi}'
    params = {'email': email}

    try:
        response = requests.get(api_url, params = params, timeout = 10)
        response.raise_for_status()
        data = response.json()

        # Check for open access PDF
        if data.get('is_oa'):
            best_oa = data.get('best_oa_location')
            if best_oa and best_oa.get('url_for_pdf'):
                return best_oa['url_for_pdf'], None

        return None, None
    except Exception as e:
        logging.error(f'Error fetching metadata for {doi}: {e}')
        return None, STATUS_NETWORK_ERROR


def is_valid_pdf(file_path):
    """Check if file is a valid PDF.

    Args:
        file_path: Path to file to check

    Returns:
        True if file appears to be a valid PDF, False otherwise
    """
    try:
        # Check file exists and has content
        if not file_path.exists() or file_path.stat().st_size == 0:
            return False

        # Check PDF magic number (header)
        with open(file_path, 'rb') as f:
            header = f.read(5)
            if not header.startswith(b'%PDF-'):
                logging.warning(f'File {file_path} does not start with PDF magic number')
                return False

            # Check for EOF marker (basic validation)
            # Read last 1024 bytes to look for %%EOF
            f.seek(max(0, file_path.stat().st_size - 1024))
            tail = f.read()
            if b'%%EOF' not in tail:
                logging.warning(f'File {file_path} missing %%EOF marker')
                return False

        return True
    except Exception as e:
        logging.error(f'Error validating PDF {file_path}: {e}')
        return False


def download_pdf(pdf_url, output_path):
    """Download PDF from URL to output path.

    Cleans up partial downloads on failure.
    Validates downloaded file is a PDF.

    Returns:
        True if successful, False otherwise
    """
    try:
        # Add headers to avoid 403 errors from some publishers
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        response = requests.get(pdf_url, headers = headers, timeout = 30, stream = True)
        response.raise_for_status()

        with open(output_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size = 8192):
                f.write(chunk)

        # Validate downloaded file is a PDF
        if not is_valid_pdf(output_path):
            logging.error(f'Downloaded file is not a valid PDF: {output_path}')
            output_path.unlink()
            return False

        return True
    except Exception as e:
        logging.error(f'Error downloading PDF: {e}')
        # Clean up partial download
        if output_path.exists():
            try:
                output_path.unlink()
            except OSError:
                pass
        return False


def doi_to_base64(doi):
    """Convert DOI to base64-encoded string."""
    doi_bytes = doi.encode('utf-8')
    b64_encoded = base64.b64encode(doi_bytes).decode('utf-8')
    # Remove padding and replace URL-unsafe characters
    b64_encoded = b64_encoded.replace('/', '_').replace('+', '-').rstrip('=')
    return b64_encoded


def doi_to_filename(doi):
    """Convert DOI to base64-encoded filename."""
    return f'{doi_to_base64(doi)}.pdf'


def load_manifest(manifest_path):
    """Load existing manifest file with validation.

    Returns:
        Dictionary mapping DOI to {base64, status}

    Logs warnings for malformed entries.
    """
    manifest = {}
    valid_statuses = {STATUS_FOUND, STATUS_NOT_FOUND}

    if manifest_path.exists():
        with open(manifest_path, 'r') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue

                parts = line.split('\t')
                if len(parts) != 3:
                    logging.warning(
                        f'Manifest line {line_num}: Expected 3 fields, got {len(parts)}. Skipping.'
                    )
                    continue

                doi, b64, status = parts

                # Validate DOI format (basic check)
                if not doi.startswith('10.'):
                    logging.warning(
                        f'Manifest line {line_num}: Invalid DOI format "{doi}". Skipping.'
                    )
                    continue

                # Validate status
                if status not in valid_statuses:
                    logging.warning(
                        f'Manifest line {line_num}: Unknown status "{status}" for DOI {doi}. '
                        f'Expected one of {valid_statuses}. Using anyway.'
                    )

                # Validate base64 encoding (basic check)
                if not b64 or any(c in b64 for c in [' ', '\t', '\n']):
                    logging.warning(
                        f'Manifest line {line_num}: Invalid base64 "{b64}" for DOI {doi}. Skipping.'
                    )
                    continue

                manifest[doi] = {'base64': b64, 'status': status}

    return manifest


def save_manifest(manifest_path, manifest):
    """Save manifest file atomically using temp file."""
    import tempfile

    # Write to temp file in same directory (ensures same filesystem)
    temp_fd, temp_path = tempfile.mkstemp(
        dir = manifest_path.parent,
        prefix = '.manifest_',
        suffix = '.tmp'
    )

    try:
        with os.fdopen(temp_fd, 'w') as f:
            for doi, info in sorted(manifest.items()):
                f.write(f'{doi}\t{info["base64"]}\t{info["status"]}\n')

        # Atomic rename (overwrites existing manifest)
        os.replace(temp_path, manifest_path)
    except Exception:
        # Clean up temp file on error
        try:
            os.unlink(temp_path)
        except OSError:
            pass
        raise


def scan_existing_pdfs(output_dir, manifest, all_dois):
    """Scan output directory for existing PDFs and update manifest.

    Args:
        output_dir: Directory containing PDFs
        manifest: Current manifest dict
        all_dois: List of all DOIs from references file

    Returns:
        Number of manifest entries updated or added
    """
    pdf_files = list(output_dir.glob('*.pdf'))
    updated_count = 0

    # Build reverse lookup: base64 -> DOI (O(n) instead of O(n²))
    b64_to_doi = {info['base64']: doi for doi, info in manifest.items()}

    # Build lookup for all_dois
    all_dois_b64 = {doi_to_base64(doi): doi for doi in all_dois}

    for pdf_file in pdf_files:
        # Extract base64 filename (without .pdf extension)
        b64_doi = pdf_file.stem

        # Find DOI using reverse lookup (O(1))
        doi_found = b64_to_doi.get(b64_doi)

        # If not in manifest, try to find matching DOI from all_dois
        if not doi_found:
            doi_found = all_dois_b64.get(b64_doi)

        # Validate PDF and mark as Found in manifest
        if doi_found and is_valid_pdf(pdf_file):
            if doi_found not in manifest:
                manifest[doi_found] = {'base64': b64_doi, 'status': STATUS_FOUND}
                updated_count += 1
            elif manifest[doi_found]['status'] != STATUS_FOUND:
                manifest[doi_found]['status'] = STATUS_FOUND
                updated_count += 1
        elif doi_found:
            # File exists but is not a valid PDF
            logging.warning(f'File {pdf_file} is not a valid PDF, removing from scan')
            manifest[doi_found] = {'base64': b64_doi, 'status': STATUS_NOT_FOUND}

    return updated_count


def main():
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description = 'Download open access PDFs using the Unpaywall API',
        formatter_class = argparse.RawDescriptionHelpFormatter,
        epilog = '''
Examples:
  %(prog)s --email user@example.com
  %(prog)s -e user@example.com -o PDFs
  %(prog)s --email user@example.com --output-dir Downloads/Papers
        '''
    )
    parser.add_argument(
        '-e', '--email',
        default = os.environ.get('EMAIL', 'user@example.com'),
        help = 'Email address for Unpaywall API (default: EMAIL env var or user@example.com)'
    )
    parser.add_argument(
        '-o', '--output-dir',
        default = 'References',
        help = 'Directory to save PDFs (default: References)'
    )
    parser.add_argument(
        '-r', '--references',
        default = 'references.txt',
        help = 'References file to parse (default: references.txt)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action = 'store_true',
        help = 'Enable verbose logging'
    )

    args = parser.parse_args()

    # Configure logging
    logging.basicConfig(
        level = logging.DEBUG if args.verbose else logging.INFO,
        format = '%(message)s'
    )

    # Configuration
    references_file = args.references
    output_dir = Path(args.output_dir)
    email = args.email

    if email == 'user@example.com':
        logging.warning('Using default email. Specify --email for better results.')

    # Create output directory
    output_dir.mkdir(exist_ok = True)

    # Load manifest
    manifest_path = output_dir / 'manifest.tsv'
    manifest = load_manifest(manifest_path)
    logging.info(f'Loaded manifest with {len(manifest)} existing entries')

    # Extract DOIs
    logging.info(f'Extracting DOIs from {references_file}...')
    dois = extract_dois(references_file)
    logging.info(f'Found {len(dois)} DOIs')

    # Scan existing PDFs and update manifest
    updated = scan_existing_pdfs(output_dir, manifest, dois)
    if updated > 0:
        logging.info(f'Updated {updated} manifest entries from existing PDFs')

    # Remove duplicates while preserving order
    unique_dois = []
    seen = set()
    for doi in dois:
        if doi not in seen:
            unique_dois.append(doi)
            seen.add(doi)

    logging.info(f'Unique DOIs: {len(unique_dois)}')

    # Download PDFs
    success_count = 0
    skip_count = 0
    fail_count = 0

    for i, doi in enumerate(unique_dois, 1):
        b64_doi = doi_to_base64(doi)
        filename = f'{b64_doi}.pdf'
        output_path = output_dir / filename

        # Skip if already in manifest with 'Found' status
        if doi in manifest and manifest[doi]['status'] == STATUS_FOUND:
            logging.info(f'[{i}/{len(unique_dois)}] Skipping {doi} (already in manifest as Found)')
            skip_count += 1
            continue

        logging.info(f'[{i}/{len(unique_dois)}] Processing {doi}...')

        # Get PDF URL from Unpaywall
        pdf_url, network_error = get_pdf_url(doi, email)

        if network_error:
            logging.warning(f'  ✗ Network/API error')
            manifest[doi] = {'base64': b64_doi, 'status': STATUS_NOT_FOUND}
            fail_count += 1
        elif pdf_url:
            logging.debug(f'  Found PDF at {pdf_url}')
            if download_pdf(pdf_url, output_path):
                logging.info(f'  ✓ Downloaded to {output_path}')
                manifest[doi] = {'base64': b64_doi, 'status': STATUS_FOUND}
                success_count += 1
            else:
                logging.warning(f'  ✗ Failed to download')
                manifest[doi] = {'base64': b64_doi, 'status': STATUS_NOT_FOUND}
                fail_count += 1
        else:
            logging.info(f'  ✗ No open access PDF available')
            manifest[doi] = {'base64': b64_doi, 'status': STATUS_NOT_FOUND}
            fail_count += 1

    # Save updated manifest
    save_manifest(manifest_path, manifest)
    logging.info(f'Updated manifest saved to {manifest_path}')

    logging.info(f'\n{"="*80}')
    logging.info(f'Summary:')
    logging.info(f'  Total DOIs: {len(unique_dois)}')
    logging.info(f'  Downloaded: {success_count}')
    logging.info(f'  Skipped (already in manifest): {skip_count}')
    logging.info(f'  Failed/Not available: {fail_count}')
    logging.info(f'{"="*80}')


if __name__ == '__main__':
    main()
